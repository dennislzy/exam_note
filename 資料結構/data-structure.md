# 資料結構完整學習筆記

## 目錄
- [陣列與矩陣](#陣列與矩陣)
- [堆疊與佇列](#堆疊與佇列)
- [鏈接串列](#鏈接串列)
- [遞迴](#遞迴)
- [樹狀結構](#樹狀結構)
- [堆積結構](#堆積結構)
- [圖形結構](#圖形結構)
- [排序演算法](#排序演算法)
- [動態規劃演算法](#動態規劃演算法)
- [雜湊表](#雜湊表)
- [複雜度分析](#複雜度分析)

---

## 動態規劃演算法

### 矩陣鏈乘法問題 (Matrix Chain Multiplication)

**問題描述**
- 給定一串矩陣 A₁, A₂, ..., Aₙ 要進行連乘
- 矩陣乘法滿足結合律：(AB)C = A(BC)
- 不同的括號放置方式會影響計算量
- 目標：找到使標量乘法次數最少的括號方式

**問題分析**

**矩陣乘法計算量**
- 兩個矩陣 A(p×q) 和 B(q×r) 相乘需要 p×q×r 次標量乘法
- 結果矩陣維度為 p×r

**範例**
考慮三個矩陣：A₁(1×100), A₂(100×1), A₃(1×100)

**方法一**：(A₁A₂)A₃
- A₁A₂：1×100×1 = 100 次乘法，結果為 1×1
- (A₁A₂)A₃：1×1×100 = 100 次乘法
- 總計：200 次乘法

**方法二**：A₁(A₂A₃)
- A₂A₃：100×1×100 = 10,000 次乘法，結果為 100×100
- A₁(A₂A₃)：1×100×100 = 10,000 次乘法
- 總計：20,000 次乘法

可見不同括號方式差異巨大！

**動態規劃解法**

**狀態定義**
- 設 m[i][j] 為計算矩陣 AᵢAᵢ₊₁...Aⱼ 所需的最少標量乘法次數
- 設 s[i][j] 記錄最佳分割點 k

**遞迴關係**
```
m[i][j] = 0                           (if i = j)
m[i][j] = min{m[i][k] + m[k+1][j] + pᵢ₋₁pₖpⱼ}  (if i < j)
          i≤k<j
```

其中 pᵢ₋₁, pᵢ 是矩陣 Aᵢ 的維度

**演算法步驟**
1. **初始化**：所有 m[i][i] = 0
2. **填表**：按鏈長度 l 從小到大計算
3. **計算**：對每個 m[i][j]，嘗試所有可能的分割點 k
4. **記錄**：在 s[i][j] 中記錄最佳分割點

**時間複雜度**：O(n³)
**空間複雜度**：O(n²)

**演算法實現**
```python
def matrix_chain_order(p):
    n = len(p) - 1  # n個矩陣
    m = [[0] * (n+1) for _ in range(n+1)]
    s = [[0] * (n+1) for _ in range(n+1)]
    
    # l 是鏈長度
    for l in range(2, n+1):
        for i in range(1, n-l+2):
            j = i + l - 1
            m[i][j] = float('inf')
            
            for k in range(i, j):
                cost = m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j]
                if cost < m[i][j]:
                    m[i][j] = cost
                    s[i][j] = k
    
    return m, s
```

**最佳括號方式重建**
```python
def print_optimal_parentheses(s, i, j):
    if i == j:
        print(f"A{i}", end="")
    else:
        print("(", end="")
        print_optimal_parentheses(s, i, s[i][j])
        print_optimal_parentheses(s, s[i][j]+1, j)
        print(")", end="")
```

**範例計算**
矩陣維度：[1, 100, 1, 100]（三個矩陣：1×100, 100×1, 1×100）

|   | 1 | 2 | 3 |
|---|---|---|---|
| 1 | 0 | 100 | 200 |
| 2 | 0 | 0 | 10000 |
| 3 | 0 | 0 | 0 |

最佳方案：(A₁A₂)A₃，需要 200 次乘法

**應用場景**
- **科學計算**：大型矩陣運算最佳化
- **計算機圖學**：變換矩陣鏈計算
- **機器學習**：神經網路權重矩陣運算
- **編譯器最佳化**：運算式計算順序最佳化

**變形問題**
- **最佳二元搜尋樹**：類似的動態規劃結構
- **多邊形三角剖分**：最少分割成本
- **括號匹配問題**：最佳配對方式

---

## 陣列與矩陣

### 多項式表示法

**方法一：依指數順序儲存係數**
- 依照指數由高到低，只儲存係數
- 第一個元素為最高指數
- **適用情況**：零項次很少時
- **優點**：簡單直觀
- **缺點**：浪費空間（需儲存所有係數，包含零項）

**方法二：只儲存非零項**
- 只儲存非零項的係數和指數
- 第一個元素存儲非零項的總數
- **適用情況**：零項次很多時（稀疏多項式）
- **優點**：節省空間
- **缺點**：需要額外儲存指數資訊

### 稀疏矩陣 (Sparse Matrix)

**3-tuple 結構**
- 第一列：存儲矩陣的行數、列數、非零元素總數
- 後續行：存儲每個非零元素的行索引、列索引、數值
- **格式**：`[row, col, value]`

**優勢**
- 大幅節省儲存空間
- 提高運算效率（只處理非零元素）

**應用場景**
- 科學計算中的大型稀疏系統
- 圖形處理中的鄰接矩陣
- 機器學習中的特徵矩陣

---

## 堆疊與佇列

### 堆疊 (Stack) 的應用

#### 表達式轉換

**運算子優先順序**（由高到低）
1. `()` 括號
2. `^` 指數運算
3. `*`, `/`, `%` 乘除模
4. `+`, `-` 加減
5. `>`, `<`, `>=`, `<=` 比較運算子
6. `==`, `!=` 等於不等於
7. `&&`, `||` 邏輯運算子

#### 中序轉後序 (Infix to Postfix)

**演算法步驟**
1. 從左到右掃描中序表達式
2. 如果是操作數，直接輸出
3. 如果是運算子：
   - 如果堆疊為空或遇到左括號，直接推入
   - 如果優先級高於堆疊頂端，推入堆疊
   - 否則彈出堆疊中優先級高於或等於當前運算子的所有運算子
4. 如果是右括號，彈出直到左括號
5. 最後彈出堆疊中所有剩餘運算子

**範例**
- 中序：`A + B * C`
- 後序：`A B C * +`

#### 中序轉前序 (Infix to Prefix)

**方法一：反向處理**
1. 反轉中序表達式
2. 將左括號改為右括號，右括號改為左括號
3. 使用中序轉後序的演算法
4. 反轉結果

**方法二：直接轉換**
- 從右到左掃描中序表達式
- 運算子放在操作數之前

#### 後序運算求值

**演算法步驟**
1. 從左到右掃描後序表達式
2. 如果是操作數，推入堆疊
3. 如果是運算子，彈出兩個操作數進行運算，結果推入堆疊
4. 最終堆疊中的元素即為結果

### 佇列 (Queue) 的應用

**特性**
- FIFO (First In, First Out)
- 主要操作：enqueue（入隊）、dequeue（出隊）

**應用場景**
- 廣度優先搜尋 (BFS)
- 工作排程
- 緩衝區管理

---

## 鏈接串列

### 基本特性

**結構特點**
- 每個節點包含資料和指向下一個節點的指標
- 記憶體使用不連續
- 動態大小調整

**記憶體比較**
- **空間開銷**：比陣列大（需儲存指標）
- **空間浪費**：主要來自指標開銷
- **記憶體效率**：在頻繁插入刪除時較佳

### 鏈接串列類型

**單向鏈接串列 (Singly Linked List)**
- 每個節點只有一個指向下一個節點的指標
- 只能單方向遍歷

**雙向鏈接串列 (Doubly Linked List)**
- 每個節點有兩個指標：前一個和下一個節點
- 可雙向遍歷

**環形鏈接串列 (Circular Linked List)**
- 最後一個節點指向第一個節點
- 形成環狀結構

### 時間複雜度比較

| 操作 | 陣列 | 鏈接串列 |
|------|------|----------|
| 存取 | O(1) | O(n) |
| 搜尋 | O(n) | O(n) |
| 插入 | O(n) | O(1)* |
| 刪除 | O(n) | O(1)* |

*註：已知節點位置時

---

## 遞迴

### 基本概念

**定義**
- 函數呼叫自己的程式設計技巧
- 必須有基底條件 (Base Case) 和遞迴條件

### 經典問題：河內塔 (Hanoi Towers)

**問題描述**
- 三根柱子：A、B、C
- n 個大小不同的圓盤
- 目標：將所有圓盤從 A 移到 C

**規則**
1. 一次只能移動一個圓盤
2. 圓盤只能放在比它大的圓盤上面

**解法公式**
- 移動步數：`2^n - 1`
- 時間複雜度：`O(2^n)`

**演算法思路**
1. 將前 n-1 個圓盤從 A 移到 B（使用 C 作輔助）
2. 將第 n 個圓盤從 A 移到 C
3. 將 n-1 個圓盤從 B 移到 C（使用 A 作輔助）

### 遞迴的優缺點

**優點**
- 程式可讀性佳
- 適合解決遞迴性結構問題
- 程式碼簡潔優雅

**缺點**
- 消耗大量記憶體（函數呼叫堆疊）
- 效率通常比迴圈慢
- 可能發生堆疊溢出
- 時間複雜度通常較高

**適用場景**
- 樹的遍歷
- 分治演算法
- 數學遞迴關係
- 組合問題

---

## 樹狀結構

### 二元樹基本概念

**定義與特性**
1. 二元樹的節點個數可以是零
2. 二元樹有左右之分
3. 每個節點的分支度 (degree) 至多為 2
4. 用陣列儲存會造成空間浪費（特別是斜樹）

**儲存方式比較**
- **陣列表示**：適合完全二元樹，索引計算簡單
- **鏈接串列表示**：適合一般二元樹，節省空間

### 二元樹遍歷

**前序遍歷 (Preorder)**
- 順序：根 → 左子樹 → 右子樹
- 應用：複製樹結構、表達式樹的前序輸出

**中序遍歷 (Inorder)**
- 順序：左子樹 → 根 → 右子樹
- 應用：二元搜尋樹會得到排序結果

**後序遍歷 (Postorder)**
- 順序：左子樹 → 右子樹 → 根
- 應用：計算目錄大小、刪除樹節點

**層序遍歷 (Level Order)**
- 從上到下、從左到右依次訪問
- 使用佇列實現
- 應用：廣度優先搜尋

### 二元搜尋樹 (Binary Search Tree, BST)

**性質**
- 左子樹的所有鍵值 < 根節點鍵值
- 右子樹的所有鍵值 > 根節點鍵值
- 左右子樹也是二元搜尋樹

**操作複雜度**
- 平均情況：O(log n)
- 最壞情況：O(n)（退化成線性結構）

**樹的重建**
- 中序 + 前序 → 唯一確定樹
- 中序 + 後序 → 唯一確定樹
- 只有前序 + 後序無法唯一確定樹

### 一般樹轉二元樹

**Left Child-Right Sibling 表示法**
1. 每個節點的第一個子節點成為左子樹
2. 其餘兄弟節點依次成為右子樹
3. 原樹的兄弟關係變成二元樹的右鏈

### 引線二元樹 (Threaded Binary Tree)

**目的**
- 利用空指標建立引線
- 優化中序遍歷，時間複雜度降為 O(n)

**引線類型**
- **左引線**：左指標為 NULL 時，指向中序前驅
- **右引線**：右指標為 NULL 時，指向中序後繼

**優點**
- 無需堆疊進行中序遍歷
- 空間利用率高

### 霍夫曼樹 (Huffman Tree)

**建構演算法**
1. 將所有字符按頻率排序
2. 重複取出兩個頻率最低的節點
3. 合併成新節點，新節點頻率為兩者之和
4. 直到形成完整的樹

**應用**
- 資料壓縮和編碼
- 最優前綴碼生成

**特性**
- 最小化加權外部路徑長度
- 不一定是平衡樹
- 左右子樹可以任意分配

### 紅黑樹 (Red-Black Tree)

**性質**
1. 每個節點要麼是紅色，要麼是黑色
2. 根節點是黑色
3. 紅色節點的兩個子節點都是黑色
4. 從根到葉子的所有路徑都包含相同數目的黑色節點

**插入調整**

**情況一：Uncle 節點是紅色**
- 將父親和 Uncle 變成黑色
- 祖父變成紅色
- 繼續向上調整

**情況二：Uncle 節點是黑色**
- **直線型**：旋轉並重新著色
- **M 字型**：先轉成直線型，再調整

**優點**
- 保證 O(log n) 的查找、插入、刪除時間
- 相對 AVL 樹，插入刪除旋轉次數較少

---

## 堆積結構

### 堆積類型

**最大堆積 (Max Heap)**
- 父節點的鍵值 ≥ 子節點的鍵值
- 根節點是最大值

**最小堆積 (Min Heap)**
- 父節點的鍵值 ≤ 子節點的鍵值
- 根節點是最小值

**最小-最大堆積 (Min-Max Heap)**
- 奇數層是最小堆積
- 偶數層是最大堆積
- 根節點在最小層

**雙端堆積 (Deap)**
- 根節點為空，不存儲資料
- 左子樹是最小堆積
- 右子樹是最大堆積
- 左右子樹節點存在對應關係

### 堆積操作

**插入 (Insert)**
1. 在堆積末尾加入新元素
2. 向上調整維持堆積性質
3. 時間複雜度：O(log n)

**刪除 (Delete)**
1. 移除根節點
2. 將最後一個元素移到根位置
3. 向下調整維持堆積性質
4. 時間複雜度：O(log n)

**應用**
- 優先佇列實現
- 堆積排序
- 最短路徑演算法（Dijkstra）

---

## 樹狀結構進階

### AVL 樹 (高度平衡二元搜尋樹)

**平衡條件**
- `|左子樹高度 - 右子樹高度| ≤ 1`
- 保持二元搜尋樹的所有性質

**旋轉類型**
- **LL 旋轉**：右旋
- **RR 旋轉**：左旋
- **LR 旋轉**：先左旋後右旋
- **RL 旋轉**：先右旋後左旋

**優點**
- 保證 O(log n) 的查找時間
- 嚴格平衡

**缺點**
- 插入刪除時旋轉頻繁
- 實現複雜

### 2-3 樹

**節點類型**
- **2-節點**：包含一個鍵值，有兩個子節點
- **3-節點**：包含兩個鍵值，有三個子節點

**性質**
- 所有葉子節點在同一層
- 完美平衡
- 是 B 樹的特例（階數為 3）

### B 樹

**定義**
- m 階 B 樹的節點最多包含 m-1 個鍵值
- 每個節點的分支度 ≤ m
- 適合外存儲器的資料結構

**應用**
- 資料庫索引
- 檔案系統

### B+ 樹

**定義與特性**
- B 樹的變形，專為資料庫和檔案系統設計
- 只有葉子節點存放實際資料
- 內部節點只存放索引鍵值

**B+ 樹與 B 樹的差異**

| 特性 | B 樹 | B+ 樹 |
|------|------|-------|
| 資料存放位置 | 所有節點 | 只在葉子節點 |
| 葉子節點連接 | 無 | 有指標連接 |
| 內部節點功能 | 存放資料和索引 | 只存放索引 |
| 範圍查詢效率 | 較低 | 高 |
| 磁碟 I/O | 不確定 | 穩定 |

**B+ 樹結構特點**

**內部節點**
- 只包含鍵值和指向子節點的指標
- 不存放實際資料記錄
- 鍵值用於導航到正確的葉子節點

**葉子節點**
- 包含所有實際資料記錄
- 葉子節點之間有指標相連（通常是雙向連結）
- 形成有序的鏈接串列

**特性**
1. **所有葉子節點在同一層**
2. **內部節點的鍵值會在葉子節點重複出現**
3. **葉子節點包含所有鍵值**
4. **葉子節點間有順序鏈接**

**操作特性**

**搜尋操作**
- 從根節點開始，根據鍵值比較決定路徑
- 最終必定到達葉子節點
- 所有搜尋的路徑長度相同

**範圍查詢**
- 找到起始鍵值對應的葉子節點
- 通過葉子節點間的鏈接順序掃描
- 非常適合範圍查詢和順序存取

**插入操作**
1. 找到對應的葉子節點
2. 如果葉子節點未滿，直接插入
3. 如果葉子節點已滿，分裂節點並向上調整

**刪除操作**
1. 找到對應的葉子節點並刪除
2. 如果節點鍵值數量不足，進行合併或借用
3. 必要時向上調整內部節點

**優點**
- **範圍查詢效率高**：葉子節點連接成鏈
- **磁碟 I/O 穩定**：所有查詢都到葉子節點
- **順序存取快速**：沿著葉子節點鏈接即可
- **併發性能好**：內部節點不存資料，鎖競爭少

**缺點**
- **空間開銷較大**：鍵值在內部節點重複
- **實現複雜度高**：需要維護葉子節點鏈接

**應用場景**
- **資料庫索引**：MySQL 的 InnoDB 引擎
- **檔案系統**：NTFS、HFS+ 等
- **需要頻繁範圍查詢的場景**

### M-way 搜尋樹

**特性**
- 每個節點最多有 m 個分支
- 每個節點最多包含 m-1 個鍵值
- 鍵值按遞增順序排列

---

## 圖形結構

### 圖形基本概念

**圖形類型**

**無向圖 (Undirected Graph)**
- 邊沒有方向性
- (V1, V2) 和 (V2, V1) 表示同一條邊

**有向圖 (Directed Graph)**
- 邊有方向性
- <V1, V2> 和 <V2, V1> 表示不同的邊

**完全圖 (Complete Graph)**
- **無向圖**：n 個頂點有 n(n-1)/2 條邊
- **有向圖**：n 個頂點有 n(n-1) 條邊

**重要名詞**

**簡單路徑 (Simple Path)**
- 路徑上除起點和終點外，其他頂點都不相同
- 例如：1→2→4→3 是簡單路徑
- 1→2→4→2 不是簡單路徑

**入度與出度**
- **入度 (In-degree)**：指向頂點 V 的邊數
- **出度 (Out-degree)**：從頂點 V 指出的邊數

**尤拉迴路 (Eulerian Cycle)**
- 恰好經過每條邊一次的迴路
- 條件：每個頂點的度數都是偶數

### 圖形表示方式

**鄰接矩陣 (Adjacency Matrix)**

**特點**
- 二維陣列表示
- 空間複雜度：O(V²)
- 查詢兩點是否相鄰：O(1)

**適用場景**
- 稠密圖（邊數接近完全圖）
- 需要快速查詢連接關係

**優缺點**
- ✅ 查詢快速
- ✅ 實現簡單
- ❌ 空間複雜度高
- ❌ 不適合稀疏圖

**鄰接串列 (Adjacency List)**

**特點**
- 每個頂點維護一個相鄰頂點的串列
- 空間複雜度：O(V + E)
- 查詢兩點是否相鄰：O(degree)

**適用場景**
- 稀疏圖
- 需要遍歷所有相鄰頂點

**優缺點**
- ✅ 空間效率高
- ✅ 插入刪除快速
- ❌ 查詢特定邊較慢

**鄰接多元串列 (Adjacency Multilist)**

**特點**
- 每條邊只存儲一次
- 每條邊由兩個頂點共享
- 維護兩個指標指向相關的下一條邊

**優點**
- 節省空間
- 適合無向圖

### 圖形遍歷

**深度優先搜尋 (Depth-First Search, DFS)**

**特性**
- 使用堆疊（或遞迴）實現
- 盡可能深入分支

**應用**
- 尋找連通分量
- 拓撲排序
- 檢測環路

**重要概念**
- **關節點 (Articulation Points)**：移除後圖變不連通的頂點
- **深度優先編號 (DFS Number)**：DFS 首次訪問的序號
- **回邊 (Back Edge)**：連接到祖先的邊
- **前向邊 (Forward Edge)**：連接到後代的邊
- **交叉邊 (Cross Edge)**：連接無祖先-後代關係的邊
- **樹邊 (Tree Edge)**：DFS 樹中的邊
- **Low 值**：通過子樹和回邊能到達的最小 DFS 編號

**廣度優先搜尋 (Breadth-First Search, BFS)**

**特性**
- 使用佇列實現
- 層層擴展搜尋

**應用**
- 最短路徑（無權重圖）
- 最小生成樹

### 最小生成樹 (Minimum Spanning Tree)

**定義**
- 連接所有頂點的最小權重樹
- 包含 n-1 條邊（n 為頂點數）

**Prim 演算法**

**步驟**
1. 從任意頂點開始
2. 每次選擇連接樹和未訪問頂點的最小權重邊
3. 重複直到包含所有頂點

**時間複雜度**：O(V²) 或 O(E log V)

**Kruskal 演算法**

**步驟**
1. 將所有邊按權重排序
2. 依序選擇邊，但不能形成環路
3. 使用 Union-Find 資料結構檢測環路

**時間複雜度**：O(E log E)

**Sollin 演算法**

**步驟**
1. 每個連通分量選擇連接其他分量的最小邊
2. 合併連通分量
3. 重複直到只剩一個分量

### 最短路徑

**Floyd-Warshall 演算法**

**概念**
- 求所有頂點對之間的最短路徑
- 使用動態規劃思想
- 通過每個頂點作為中繼點更新最短路徑

**時間複雜度**：O(V³)
**空間複雜度**：O(V²)

**核心思想**
```
for k in range(V):
    for i in range(V):
        for j in range(V):
            dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
```

### 遞移封閉性 (Transitive Closure)

**定義**
- 決定任意兩頂點間是否存在路徑
- 路徑長度 > 0 時設為 1，否則為 0

**反射遞移封閉性 (Reflexive Transitive Closure)**
- 同遞移封閉性，但對角線元素設為 1

### 拓撲排序 (Topological Sort)

**定義**
- 對有向無環圖 (DAG) 的頂點進行線性排序
- 若存在邊 u → v，則 u 在 v 之前

**演算法**
1. 找出入度為 0 的頂點
2. 輸出該頂點並移除相關邊
3. 重複步驟 1-2 直到所有頂點都被處理

**應用**
- 課程安排
- 編譯依賴關係
- 任務調度

**AOV 網路表示**
- 開頭節點：存放該頂點的入度
- 後續節點：存放相鄰頂點

---

## 排序演算法

### 簡單排序演算法

**氣泡排序 (Bubble Sort)**

**演算法概念**
- 重複比較相鄰元素，較大者往後移
- 每次遍歷確定一個最大值的位置

**時間複雜度**
- **最佳情況**：O(n)（已排序）
- **最壞情況**：O(n²)
- **平均情況**：O(n²)

**程式碼**
```java
for (int i = 0; i < arr.length - 1; i++) {
    for (int j = 0; j < arr.length - 1 - i; j++) {
        if (arr[j] > arr[j + 1]) {
            swap(arr, j, j + 1);
        }
    }
}
```

**選擇排序 (Selection Sort)**

**演算法概念**
- 每次從未排序部分選出最小值
- 放到已排序部分的末尾

**時間複雜度**
- **所有情況**：O(n²)
- 比較次數固定：n(n-1)/2

**程式碼**
```java
for (int i = 0; i < arr.length - 1; i++) {
    int minIndex = i;
    for (int j = i + 1; j < arr.length; j++) {
        if (arr[j] < arr[minIndex]) {
            minIndex = j;
        }
    }
    if (minIndex != i) {
        swap(arr, i, minIndex);
    }
}
```

**插入排序 (Insertion Sort)**

**演算法概念**
- 將陣列分為已排序和未排序兩部分
- 每次取未排序的元素插入到已排序的正確位置

**時間複雜度**
- **最佳情況**：O(n)（已排序）
- **最壞情況**：O(n²)（反向排序）
- **平均情況**：O(n²)

**程式碼**
```java
for (int i = 1; i < arr.length; i++) {
    int key = arr[i];
    int j = i - 1;
    while (j >= 0 && arr[j] > key) {
        arr[j + 1] = arr[j];
        j--;
    }
    arr[j + 1] = key;
}
```

### 進階排序演算法

**快速排序 (Quick Sort)**

**演算法概念**
- 選擇樞軸 (pivot)
- 將陣列分為小於樞軸和大於樞軸兩部分
- 遞迴排序兩部分

**時間複雜度**
- **最佳情況**：O(n log n)（平衡分割）
- **最壞情況**：O(n²)（最大或最小元素為樞軸）
- **平均情況**：O(n log n)

**程式碼**
```java
public static int partition(int[] arr, int left, int right) {
    int pivot = arr[left];
    while (left < right) {
        while (arr[right] >= pivot && left < right) {
            right--;
        }
        arr[left] = arr[right];
        while (arr[left] <= pivot && left < right) {
            left++;
        }
        arr[right] = arr[left];
    }
    arr[left] = pivot;
    return left;
}
```

**合併排序 (Merge Sort)**

**演算法概念**
- 採用分治法 (Divide and Conquer)
- 將陣列遞迴分割為兩半
- 合併已排序的子陣列

**特性**
- **穩定排序**：相等元素的相對位置不變
- **時間複雜度**：所有情況都是 O(n log n)
- **空間複雜度**：O(n)

**優點**
- 時間複雜度穩定
- 適合大數據排序
- 可以外部排序

**堆積排序 (Heap Sort)**

**演算法概念**
1. 建立最大堆積
2. 將堆積頂端（最大值）與最後元素交換
3. 重新調整堆積
4. 重複步驟 2-3

**特性**
- **時間複雜度**：O(n log n)
- **空間複雜度**：O(1)
- **不穩定排序**

**基數排序 (Radix Sort)**

**演算法概念**
- 非比較型排序
- 按照數字的每一位進行排序
- 從最低位到最高位（或相反）

**時間複雜度**：O(d × (n + k))
- d：數字位數
- n：元素個數
- k：每位可能的值數量

**特性**
- **穩定排序**
- **空間複雜度**：O(n + k)
- 適用於整數或固定長度字串

### 排序演算法比較

| 排序演算法 | 最佳時間 | 平均時間 | 最壞時間 | 空間複雜度 | 穩定性 |
|-----------|----------|----------|----------|------------|---------|
| 氣泡排序 | O(n) | O(n²) | O(n²) | O(1) | 穩定 |
| 選擇排序 | O(n²) | O(n²) | O(n²) | O(1) | 不穩定 |
| 插入排序 | O(n) | O(n²) | O(n²) | O(1) | 穩定 |
| 快速排序 | O(n log n) | O(n log n) | O(n²) | O(log n) | 不穩定 |
| 合併排序 | O(n log n) | O(n log n) | O(n log n) | O(n) | 穩定 |
| 堆積排序 | O(n log n) | O(n log n) | O(n log n) | O(1) | 不穩定 |
| 基數排序 | O(d(n+k)) | O(d(n+k)) | O(d(n+k)) | O(n+k) | 穩定 |

---

## 雜湊表

### 基本概念

**重要名詞**

**桶 (Bucket)**
- 記憶空間分割成 b 個桶
- 每個桶可存放多筆資料

**槽 (Slot)**
- 每個桶包含 s 個槽
- 每個槽存放一筆記錄

**識別字密度 (Identifier Density)**
- 公式：n / T
- n：實際使用的識別字個數
- T：可能的識別字總數

**負載因子 (Load Factor)**
- 公式：α = n / (s × b)
- 值越大，碰撞機率越高

**碰撞 (Collision)**
- 兩個不同的鍵值對應到同一個桶

**溢位 (Overflow)**
- 鍵值對應的桶已滿

### 雜湊函數

**理想特性**
- **均勻雜湊函數 (Uniform Hashing)**：每個鍵值等機率對應到任一桶
- **完美雜湊 (Perfect Hashing)**：保證不會發生碰撞

**常見雜湊函數**

**除法 (Division Method)**
```
h(k) = k mod m
```
- m 通常選擇質數
- 簡單易實現
- 要避免 m 為 2 的冪次

**平方取中法 (Mid-Square Method)**
1. 將鍵值平方
2. 取平方結果的中間幾位作為雜湊值
3. 例如：8125² = 66015625，取中間三位 156

**摺疊法 (Folding Method)**

**移位摺疊 (Shift Folding)**
- 將鍵值分段後直接相加
- 例如：41|55|28|09|67 → 41+55+28+09+67

**邊界摺疊 (Boundary Folding)**
- 相鄰部分交替反轉再相加
- 例如：41|55|28|09|67 → 41+55+82+90+67

**位數分析法 (Digit Analysis)**
1. 分析鍵值中各位數字的分布
2. 選擇分布最均勻的位數
3. 組合成雜湊值

### 處理碰撞的方法

**開放定址法 (Open Addressing)**

**線性探測 (Linear Probing)**
- 發生碰撞時，依序檢查下一個位置
- 公式：h(k, i) = (h(k) + i) mod m
- **缺點**：容易產生群聚現象 (clustering)

**二次探測 (Quadratic Probing)**
- 使用二次函數探測
- 公式：h(k, i) = (h(k) ± i²) mod m
- 減少群聚問題

**雙重雜湊 (Double Hashing)**
- 使用第二個雜湊函數決定探測步長
- 公式：h(k, i) = (h₁(k) + i × h₂(k)) mod m

**鏈接法 (Chaining)**
- 每個桶維護一個鏈接串列
- 碰撞的元素加入對應桶的串列
- **優點**：簡單、不會滿
- **缺點**：需要額外指標空間

### 雜湊表效能分析

**負載因子與效能關係**
- α < 0.5：效能良好
- α ≈ 0.75：平衡點
- α > 0.9：效能明顯下降

**平均搜尋時間**
- **成功搜尋**：約 1 + α/2
- **失敗搜尋**：約 1 + α

**動態調整**
- 當負載因子過高時，進行重新雜湊 (rehashing)
- 建立更大的雜湊表並重新插入所有元素

---

## 複雜度分析

### 時間複雜度

**常見複雜度排序**（由快到慢）
1. **O(1)**：常數時間
2. **O(log n)**：對數時間
3. **O(n)**：線性時間
4. **O(n log n)**：線性對數時間
5. **O(n²)**：平方時間
6. **O(n³)**：立方時間
7. **O(2ⁿ)**：指數時間
8. **O(n!)**：階乘時間

**分析技巧**
- **最佳情況 (Best Case)**：輸入最理想的情況
- **最壞情況 (Worst Case)**：輸入最不利的情況
- **平均情況 (Average Case)**：所有可能輸入的平均表現

### 空間複雜度

**考慮因素**
- 輸入空間：存放輸入資料
- 輔助空間：演算法執行時的額外空間
- 輸出空間：存放輸出結果

**常見空間複雜度**
- **O(1)**：就地演算法
- **O(log n)**：遞迴深度
- **O(n)**：線性額外空間
- **O(n²)**：二維陣列

### 資料結構操作複雜度總結

| 資料結構 | 存取 | 搜尋 | 插入 | 刪除 | 空間 |
|----------|------|------|------|------|------|
| 陣列 | O(1) | O(n) | O(n) | O(n) | O(n) |
| 動態陣列 | O(1) | O(n) | O(1)* | O(n) | O(n) |
| 鏈接串列 | O(n) | O(n) | O(1) | O(1) | O(n) |
| 堆疊 | O(n) | O(n) | O(1) | O(1) | O(n) |
| 佇列 | O(n) | O(n) | O(1) | O(1) | O(n) |
| 二元搜尋樹 | O(log n) | O(log n) | O(log n) | O(log n) | O(n) |
| AVL 樹 | O(log n) | O(log n) | O(log n) | O(log n) | O(n) |
| 紅黑樹 | O(log n) | O(log n) | O(log n) | O(log n) | O(n) |
| 雜湊表 | - | O(1)* | O(1)* | O(1)* | O(n) |

*註：平均情況，最壞情況可能較差

### 選擇合適的資料結構

**考慮因素**
1. **操作頻率**：哪些操作最常用？
2. **資料大小**：預期處理多少資料？
3. **記憶體限制**：空間使用是否重要？
4. **實時需求**：是否需要保證最壞情況效能？

**應用場景建議**

**需要快速隨機存取**
- 使用陣列或動態陣列

**頻繁插入刪除**
- 使用鏈接串列或平衡樹

**需要排序資料**
- 使用二元搜尋樹或堆積

**需要快速查找**
- 使用雜湊表或平衡樹

**需要範圍查詢**
- 使用 B 樹或跳躍表

**處理圖形問題**
- 鄰接矩陣（稠密圖）或鄰接串列（稀疏圖）

---