# 資料結構完整學習筆記

## 目錄
- [動態規劃演算法](#動態規劃演算法)
- [陣列與矩陣](#陣列與矩陣)
- [堆疊與佇列](#堆疊與佇列)
- [鏈接串列](#鏈接串列)
- [遞迴](#遞迴)
- [樹狀結構](#樹狀結構)
- [堆積結構](#堆積結構)
- [樹狀結構進階](#樹狀結構進階)
- [圖形結構](#圖形結構)
- [排序演算法](#排序演算法)
- [雜湊表](#雜湊表)
- [複雜度分析](#複雜度分析)

---

## 動態規劃演算法
[⬆️ 回到目錄](#目錄)

### 矩陣鏈乘法問題 (Matrix Chain Multiplication)

**問題描述**
- 給定一串矩陣 A₁, A₂, ..., Aₙ 要進行連乘
- 矩陣乘法滿足結合律：(AB)C = A(BC)
- 不同的括號放置方式會影響計算量
- 目標：找到使標量乘法次數最少的括號方式

**問題分析**

**矩陣乘法計算量**
- 兩個矩陣 A(p×q) 和 B(q×r) 相乘需要 p×q×r 次標量乘法
- 結果矩陣維度為 p×r

**範例**
考慮三個矩陣：A₁(1×100), A₂(100×1), A₃(1×100)

**方法一**：(A₁A₂)A₃
- A₁A₂：1×100×1 = 100 次乘法，結果為 1×1
- (A₁A₂)A₃：1×1×100 = 100 次乘法
- 總計：200 次乘法

**方法二**：A₁(A₂A₃)
- A₂A₃：100×1×100 = 10,000 次乘法，結果為 100×100
- A₁(A₂A₃)：1×100×100 = 10,000 次乘法
- 總計：20,000 次乘法

可見不同括號方式差異巨大！

**動態規劃解法**

**狀態定義**
- 設 m[i][j] 為計算矩陣 AᵢAᵢ₊₁...Aⱼ 所需的最少標量乘法次數
- 設 s[i][j] 記錄最佳分割點 k

**遞迴關係**
```
m[i][j] = 0                           (if i = j)
m[i][j] = min{m[i][k] + m[k+1][j] + pᵢ₋₁pₖpⱼ}  (if i < j)
          i≤k<j
```

其中 pᵢ₋₁, pᵢ 是矩陣 Aᵢ 的維度

**演算法步驟**
1. **初始化**：所有 m[i][i] = 0
2. **填表**：按鏈長度 l 從小到大計算
3. **計算**：對每個 m[i][j]，嘗試所有可能的分割點 k
4. **記錄**：在 s[i][j] 中記錄最佳分割點

**時間複雜度**：O(n³)
**空間複雜度**：O(n²)

**演算法實現**
```python
def matrix_chain_order(p):
    n = len(p) - 1  # n個矩陣
    m = [[0] * (n+1) for _ in range(n+1)]
    s = [[0] * (n+1) for _ in range(n+1)]
    
    # l 是鏈長度
    for l in range(2, n+1):
        for i in range(1, n-l+2):
            j = i + l - 1
            m[i][j] = float('inf')
            
            for k in range(i, j):
                cost = m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j]
                if cost < m[i][j]:
                    m[i][j] = cost
                    s[i][j] = k
    
    return m, s
```

**最佳括號方式重建**
```python
def print_optimal_parentheses(s, i, j):
    if i == j:
        print(f"A{i}", end="")
    else:
        print("(", end="")
        print_optimal_parentheses(s, i, s[i][j])
        print_optimal_parentheses(s, s[i][j]+1, j)
        print(")", end="")
```

**範例計算**
矩陣維度：[1, 100, 1, 100]（三個矩陣：1×100, 100×1, 1×100）

|   | 1 | 2 | 3 |
|---|---|---|---|
| 1 | 0 | 100 | 200 |
| 2 | 0 | 0 | 10000 |
| 3 | 0 | 0 | 0 |

最佳方案：(A₁A₂)A₃，需要 200 次乘法

**應用場景**
- **科學計算**：大型矩陣運算最佳化
- **計算機圖學**：變換矩陣鏈計算
- **機器學習**：神經網路權重矩陣運算
- **編譯器最佳化**：運算式計算順序最佳化

**變形問題**
- **最佳二元搜尋樹**：類似的動態規劃結構
- **多邊形三角剖分**：最少分割成本
- **括號匹配問題**：最佳配對方式

---

## 陣列與矩陣
[⬆️ 回到目錄](#目錄)

### 多項式表示法

**方法一：依指數順序儲存係數**
- 依照指數由高到低，只儲存係數
- 第一個元素為最高指數
- **適用情況**：零項次很少時
- **優點**：簡單直觀
- **缺點**：浪費空間（需儲存所有係數，包含零項）

**方法二：只儲存非零項**
- 只儲存非零項的係數和指數
- 第一個元素存儲非零項的總數
- **適用情況**：零項次很多時（稀疏多項式）
- **優點**：節省空間
- **缺點**：需要額外儲存指數資訊

### 多維陣列記憶體布局

#### 二維陣列地址計算

**Row-Major Ordering (列優先)**
```
Address(A[i][j]) = Base + ((i_offset × n) + j_offset) × element_size
```

**Column-Major Ordering (行優先)**
```
Address(A[i][j]) = Base + ((j_offset × m) + i_offset) × element_size
```

**題目範例**
給定陣列 `A[-3:8, -5:14]`，起始位置 = 100，元素大小 d = 2
求 `A[3,8]` 在 Row-Major 和 Column-Major 的記憶體位置

**陣列分析**
- 第一維：-3 到 8，共 12 個元素 (m = 12)
- 第二維：-5 到 14，共 20 個元素 (n = 20)
- 對於 A[3,8]：
  - i_offset = 3 - (-3) = 6
  - j_offset = 8 - (-5) = 13

**Row-Major 計算**
```
Address = 100 + ((6 × 20) + 13) × 2
        = 100 + (120 + 13) × 2  
        = 100 + 133 × 2
        = 100 + 266
        = 366
```

**Column-Major 計算**
```
Address = 100 + ((13 × 12) + 6) × 2
        = 100 + (156 + 6) × 2
        = 100 + 162 × 2  
        = 100 + 324
        = 424
```

**結果**
- Row-Major：A[3,8] 位於記憶體位置 **366**
- Column-Major：A[3,8] 位於記憶體位置 **424**

#### 三維陣列地址計算

**Row-Major Ordering**
```
Address(A[i][j][k]) = Base + ((i_offset × n × p) + (j_offset × p) + k_offset) × element_size
```

**Column-Major Ordering**
```
Address(A[i][j][k]) = Base + ((k_offset × m × n) + (j_offset × m) + i_offset) × element_size
```

**題目範例**
給定陣列 `A[-2:3, 1:6, -1:4]`，起始位置 = 200，元素大小 d = 4
求 `A[1,3,-1]` 在 Row-Major 和 Column-Major 的記憶體位置

**陣列分析**
- 第一維：-2 到 3，共 6 個元素 (m = 6)
- 第二維：1 到 6，共 6 個元素 (n = 6)
- 第三維：-1 到 4，共 6 個元素 (p = 6)
- 對於 A[1,3,-1]：
  - i_offset = 1 - (-2) = 3
  - j_offset = 3 - 1 = 2
  - k_offset = -1 - (-1) = 0

**Row-Major 計算**
```
Address = 200 + ((3 × 6 × 6) + (2 × 6) + 0) × 4
        = 200 + (108 + 12 + 0) × 4
        = 200 + 120 × 4
        = 200 + 480
        = 680
```

**Column-Major 計算**
```
Address = 200 + ((0 × 6 × 6) + (2 × 6) + 3) × 4
        = 200 + (0 + 12 + 3) × 4
        = 200 + 15 × 4
        = 200 + 60
        = 260
```

**結果**
- Row-Major：A[1,3,-1] 位於記憶體位置 **680**
- Column-Major：A[1,3,-1] 位於記憶體位置 **260**

### 稀疏矩陣 (Sparse Matrix)

**3-tuple 結構**
- 第一列：存儲矩陣的行數、列數、非零元素總數
- 後續行：存儲每個非零元素的行索引、列索引、數值
- **格式**：`[row, col, value]`

**優勢**
- 大幅節省儲存空間
- 提高運算效率（只處理非零元素）

**應用場景**
- 科學計算中的大型稀疏系統
- 圖形處理中的鄰接矩陣
- 機器學習中的特徵矩陣

---

## 堆疊與佇列
[⬆️ 回到目錄](#目錄)

### 堆疊 (Stack) 的應用

#### 表達式轉換

**運算子優先順序**（由高到低）
1. `()` 括號
2. `^` 指數運算
3. `*`, `/`, `%` 乘除模
4. `+`, `-` 加減
5. `>`, `<`, `>=`, `<=` 比較運算子
6. `==`, `!=` 等於不等於
7. `&&`, `||` 邏輯運算子

#### 中序轉後序 (Infix to Postfix)

**演算法步驟**
1. 從左到右掃描中序表達式
2. 如果是操作數，直接輸出
3. 如果是運算子：
   - 如果堆疊為空或遇到左括號，直接推入
   - 如果優先級高於堆疊頂端，推入堆疊
   - 否則彈出堆疊中優先級高於或等於當前運算子的所有運算子
4. 如果是右括號，彈出直到左括號
5. 最後彈出堆疊中所有剩餘運算子

**範例**
- 中序：`A + B * C`
- 後序：`A B C * +`

#### 中序轉前序 (Infix to Prefix)

**方法一：反向處理**
1. 反轉中序表達式
2. 將左括號改為右括號，右括號改為左括號
3. 使用中序轉後序的演算法
4. 反轉結果

**方法二：直接轉換**
- 從右到左掃描中序表達式
- 運算子放在操作數之前

#### 後序運算求值

**演算法步驟**
1. 從左到右掃描後序表達式
2. 如果是操作數，推入堆疊
3. 如果是運算子，彈出兩個操作數進行運算，結果推入堆疊
4. 最終堆疊中的元素即為結果

### 佇列 (Queue) 的應用

**特性**
- FIFO (First In, First Out)
- 主要操作：enqueue（入隊）、dequeue（出隊）

**應用場景**
- 廣度優先搜尋 (BFS)
- 工作排程
- 緩衝區管理

---

## 鏈接串列
[⬆️ 回到目錄](#目錄)

### 基本特性

**結構特點**
- 每個節點包含資料和指向下一個節點的指標
- 記憶體使用不連續
- 動態大小調整

**記憶體比較**
- **空間開銷**：比陣列大（需儲存指標）
- **空間浪費**：主要來自指標開銷
- **記憶體效率**：在頻繁插入刪除時較佳

### 鏈接串列類型

**單向鏈接串列 (Singly Linked List)**
- 每個節點只有一個指向下一個節點的指標
- 只能單方向遍歷

**雙向鏈接串列 (Doubly Linked List)**
- 每個節點有兩個指標：前一個和下一個節點
- 可雙向遍歷

**環形鏈接串列 (Circular Linked List)**
- 最後一個節點指向第一個節點
- 形成環狀結構

### 時間複雜度比較

| 操作 | 陣列 | 鏈接串列 |
|------|------|----------|
| 存取 | O(1) | O(n) |
| 搜尋 | O(n) | O(n) |
| 插入 | O(n) | O(1)* |
| 刪除 | O(n) | O(1)* |

*註：已知節點位置時

---

## 遞迴
[⬆️ 回到目錄](#目錄)

### 基本概念

**定義**
- 函數呼叫自己的程式設計技巧
- 必須有基底條件 (Base Case) 和遞迴條件

### 經典問題：河內塔 (Hanoi Towers)

**問題描述**
- 三根柱子：A、B、C
- n 個大小不同的圓盤
- 目標：將所有圓盤從 A 移到 C

**規則**
1. 一次只能移動一個圓盤
2. 圓盤只能放在比它大的圓盤上面

**解法公式**
- 移動步數：`2^n - 1`
- 時間複雜度：`O(2^n)`

**演算法思路**
1. 將前 n-1 個圓盤從 A 移到 B（使用 C 作輔助）
2. 將第 n 個圓盤從 A 移到 C
3. 將 n-1 個圓盤從 B 移到 C（使用 A 作輔助）

### 遞迴的優缺點

**優點**
- 程式可讀性佳
- 適合解決遞迴性結構問題
- 程式碼簡潔優雅

**缺點**
- 消耗大量記憶體（函數呼叫堆疊）
- 效率通常比迴圈慢
- 可能發生堆疊溢出
- 時間複雜度通常較高

**適用場景**
- 樹的遍歷
- 分治演算法
- 數學遞迴關係
- 組合問題

---

## 樹狀結構
[⬆️ 回到目錄](#目錄)

### 二元樹基本概念

**定義與特性**
1. 二元樹的節點個數可以是零
2. 二元樹有左右之分
3. 每個節點的分支度 (degree) 至多為 2
4. 用陣列儲存會造成空間浪費（特別是斜樹）

**儲存方式比較**
- **陣列表示**：適合完全二元樹，索引計算簡單
- **鏈接串列表示**：適合一般二元樹，節省空間

### 二元樹遍歷

**前序遍歷 (Preorder)**
- 順序：根 → 左子樹 → 右子樹
- 應用：複製樹結構、表達式樹的前序輸出

**中序遍歷 (Inorder)**
- 順序：左子樹 → 根 → 右子樹
- 應用：二元搜尋樹會得到排序結果

**後序遍歷 (Postorder)**
- 順序：左子樹 → 右子樹 → 根
- 應用：計算目錄大小、刪除樹節點

**層序遍歷 (Level Order)**
- 從上到下、從左到右依次訪問
- 使用佇列實現
- 應用：廣度優先搜尋

### 二元搜尋樹 (Binary Search Tree, BST)

**性質**
- 左子樹的所有鍵值 < 根節點鍵值
- 右子樹的所有鍵值 > 根節點鍵值
- 左右子樹也是二元搜尋樹

**操作複雜度**
- 平均情況：O(log n)
- 最壞情況：O(n)（退化成線性結構）

**樹的重建**
- 中序 + 前序 → 唯一確定樹
- 中序 + 後序 → 唯一確定樹
- 只有前序 + 後序無法唯一確定樹

### 一般樹轉二元樹

**Left Child-Right Sibling 表示法**
1. 每個節點的第一個子節點成為左子樹
2. 其餘兄弟節點依次成為右子樹
3. 原樹的兄弟關係變成二元樹的右鏈

### 引線二元樹 (Threaded Binary Tree)

**目的**
- 利用空指標建立引線
- 優化中序遍歷，時間複雜度降為 O(n)

**引線類型**
- **左引線**：左指標為 NULL 時，指向中序前驅
- **右引線**：右指標為 NULL 時，指向中序後繼

**優點**
- 無需堆疊進行中序遍歷
- 空間利用率高

### 霍夫曼樹 (Huffman Tree)

**建構演算法**
1. 將所有字符按頻率排序
2. 重複取出兩個頻率最低的節點
3. 合併成新節點，新節點頻率為兩者之和
4. 直到形成完整的樹

**應用**
- 資料壓縮和編碼
- 最優前綴碼生成

**特性**
- 最小化加權外部路徑長度
- 不一定是平衡樹
- 左右子樹可以任意分配

### 紅黑樹 (Red-Black Tree)

**性質**
1. 每個節點要麼是紅色，要麼是黑色
2. 根節點是黑色
3. 紅色節點的兩個子節點都是黑色
4. 從根到葉子的所有路徑都包含相同數目的黑色節點

**插入調整**

**情況一：Uncle 節點是紅色**
- 將父親和 Uncle 變成黑色
- 祖父變成紅色
- 繼續向上調整

**情況二：Uncle 節點是黑色**
- **直線型**：旋轉並重新著色
- **M 字型**：先轉成直線型，再調整

**優點**
- 保證 O(log n) 的查找、插入、刪除時間
- 相對 AVL 樹，插入刪除旋轉次數較少

---

## 堆積結構
[⬆️ 回到目錄](#目錄)

### 堆積類型

**最大堆積 (Max Heap)**
- 父節點的鍵值 ≥ 子節點的鍵值
- 根節點是最大值

**最小堆積 (Min Heap)**
- 父節點的鍵值 ≤ 子節點的鍵值
- 根節點是最小值

**最小-最大堆積 (Min-Max Heap)**
- 奇數層是最小堆積
- 偶數層是最大堆積
- 根節點在最小層

**雙端堆積 (Deap)**
- 根節點為空，不存儲資料
- 左子樹是最小堆積
- 右子樹是最大堆積
- 左右子樹節點存在對應關係

### 堆積操作

**插入 (Insert)**
1. 在堆積末尾加入新元素
2. 向上調整維持堆積性質
3. 時間複雜度：O(log n)

**刪除 (Delete)**
1. 移除根節點
2. 將最後一個元素移到根位置
3. 向下調整維持堆積性質
4. 時間複雜度：O(log n)

**應用**
- 優先佇列實現
- 堆積排序
- 最短路徑演算法（Dijkstra）

---

## 樹狀結構進階
[⬆️ 回到目錄](#目錄)

### AVL 樹 (高度平衡二元搜尋樹)

**平衡條件**
- `|左子樹高度 - 右子樹高度| ≤ 1`
- 保持二元搜尋樹的所有性質

**旋轉類型**
- **LL 旋轉**：右旋
- **RR 旋轉**：左旋
- **LR 旋轉**：先左旋後右旋
- **RL 旋轉**：先右旋後左旋

**優點**
- 保證 O(log n) 的查找時間
- 嚴格平衡

**缺點**
- 插入刪除時旋轉頻繁
- 實現複雜

### 2-3 樹

**節點類型**
- **2-節點**：包含一個鍵值，有兩個子節點
- **3-節點**：包含兩個鍵值，有三個子節點

**性質**
- 所有葉子節點在同一層
- 完美平衡
- 是 B 樹的特例（階數為 3）

### B 樹

**定義**
- m 階 B 樹的節點最多包含 m-1 個鍵值
- 每個節點的分支度 ≤ m
- 適合外存儲器的資料結構

**應用**
- 資料庫索引
- 檔案系統

### B+ 樹

**定義與特性**
- B 樹的變形，專為資料庫和檔案系統設計
- 只有葉子節點存放實際資料
- 內部節點只存放索引鍵值

**B+ 樹與 B 樹的差異**

| 特性 | B 樹 | B+ 樹 |
|------|------|-------|
| 資料存放位置 | 所有節點 | 只在葉子節點 |
| 葉子節點連接 | 無 | 有指標連接 |
| 內部節點功能 | 存放資料和索引 | 只存放索引 |
| 範圍查詢效率 | 較低 | 高 |
| 磁碟 I/O | 不確定 | 穩定 |

**B+ 樹結構特點**

**內部節點**
- 只包含鍵值和指向子節點的指標
- 不存放實際資料記錄
- 鍵值用於導航到正確的葉子節點

**葉子節點**
- 包含所有實際資料記錄
- 葉子節點之間有指標相連（通常是雙向連結）
- 形成有序的鏈接串列

**特性**
1. **所有葉子節點在同一層**
2. **內部節點的鍵值會在葉子節點重複出現**
3. **葉子節點包含所有鍵值**
4. **葉子節點間有順序鏈接**

**操作特性**

**搜尋操作**
- 從根節點開始，根據鍵值比較決定路徑
- 最終必定到達葉子節點
- 所有搜尋的路徑長度相同

**範圍查詢**
- 找到起始鍵值對應的葉子節點
- 通過葉子節點間的鏈接順序掃描
- 非常適合範圍查詢和順序存取

**插入操作**
1. 找到對應的葉子節點
2. 如果葉子節點未滿，直接插入
3. 如果葉子節點已滿，分裂節點並向上調整

**刪除操作**
1. 找到對應的葉子節點並刪除
2. 如果節點鍵值數量不足，進行合併或借用
3. 必要時向上調整內部節點

**優點**
- **範圍查詢效率高**：葉子節點連接成鏈
- **磁碟 I/O 穩定**：所有查詢都到葉子節點
- **順序存取快速**：沿著葉子節點鏈接即可
- **併發性能好**：內部節點不存資料，鎖競爭少

**缺點**
- **空間開銷較大**：鍵值在內部節點重複
- **實現複雜度高**：需要維護葉子節點鏈接

**應用場景**
- **資料庫索引**：MySQL 的 InnoDB 引擎
- **檔案系統**：NTFS、HFS+ 等
- **需要頻繁範圍查詢的場景**

### M-way 搜尋樹

**特性**
- 每個節點最多有 m 個分支
- 每個節點最多包含 m-1 個鍵值
- 鍵值按遞增順序排列

---

## 圖形結構
[⬆️ 回到目錄](#目錄)

### 圖形基本概念

**圖形類型**

**無向圖 (Undirected Graph)**
- 邊沒有方向性
- (V1, V2) 和 (V2, V1) 表示同一條邊

**有向圖 (Directed Graph)**
- 邊有方向性
- <V1, V2> 和 <V2, V1> 表示不同的邊

**完全圖 (Complete Graph)**
- **無向圖**：n 個頂點有 n(n-1)/2 條邊
- **有向圖**：n 個頂點有 n(n-1) 條邊

**二部圖 (Bipartite Graph)**

**白話概念說明**
- 二部圖就是可以把所有頂點分成**兩組**的圖
- 這兩組頂點有個特殊規則：**只能跨組連線，不能同組連線**
- 第一組的頂點只能連到第二組的頂點
- 第二組的頂點只能連到第一組的頂點
- 同一組內的頂點之間絕對不能有邊

**核心特徵**
- 圖中的所有頂點可以用**兩種顏色**完全著色
- 相鄰的頂點一定是不同顏色
- 如果圖中有**奇數長度的環**（如三角形），就不是二部圖

**生活例子幫助理解**

**例子一：學校舞會**
```
男生組: {小明, 小華, 小強}
女生組: {小美, 小芳, 小麗}

配對關係:
小明 ─── 小美
小明 ─── 小芳  
小華 ─── 小芳
小強 ─── 小麗
```
- 只有男女生可以配對跳舞
- 男生之間不配對，女生之間也不配對

**如何判斷是否為二部圖**

**方法：著色法**
1. 隨便選一個頂點塗成紅色
2. 把它的所有鄰居塗成藍色
3. 把藍色頂點的所有鄰居塗成紅色
4. 繼續這個過程
5. **成功** = 沒有相鄰頂點同色 → 是二部圖
6. **失敗** = 出現相鄰頂點同色 → 不是二部圖

**反例：為什麼三角形不是二部圖**
```
   A (紅)
  /     \
B(藍)─── C(?)
```
A 塗紅色，B 和 C 必須塗藍色，但 B 和 C 相鄰卻同色！產生衝突。

**完全二部圖**
- 第一組每個頂點都連到第二組每個頂點
- 如果第一組有 m 個頂點，第二組有 n 個頂點
- 總共有 m × n 條邊
- 記作 K_{m,n}

**實際應用**
- **配對網站**：用戶和商品的配對
- **工作媒合**：求職者和職缺匹配  
- **推薦系統**：用戶和推薦項目
- **網路安全**：資源和權限的分配

**重要名詞**

**簡單路徑 (Simple Path)**
- 路徑上除起點和終點外，其他頂點都不相同
- 例如：1→2→4→3 是簡單路徑
- 1→2→4→2 不是簡單路徑

**入度與出度**
- **入度 (In-degree)**：指向頂點 V 的邊數
- **出度 (Out-degree)**：從頂點 V 指出的邊數

**尤拉迴路 (Eulerian Cycle)**
- 恰好經過每條邊一次的迴路
- 條件：每個頂點的度數都是偶數

### 圖形表示方式

**鄰接矩陣 (Adjacency Matrix)**

**特點**
- 二維陣列表示
- 空間複雜度：O(V²)
- 查詢兩點是否相鄰：O(1)

**適用場景**
- 稠密圖（邊數接近完全圖）
- 需要快速查詢連接關係

**優缺點**
- ✅ 查詢快速
- ✅ 實現簡單
- ❌ 空間複雜度高
- ❌ 不適合稀疏圖

**鄰接串列 (Adjacency List)**

**特點**
- 每個頂點維護一個相鄰頂點的串列
- 空間複雜度：O(V + E)
- 查詢兩點是否相鄰：O(degree)

**適用場景**
- 稀疏圖
- 需要遍歷所有相鄰頂點

**優缺點**
- ✅ 空間效率高
- ✅ 插入刪除快速
- ❌ 查詢特定邊較慢

**鄰接多元串列 (Adjacency Multilist)**

**特點**
- 每條邊只存儲一次
- 每條邊由兩個頂點共享
- 維護兩個指標指向相關的下一條邊

**優點**
- 節省空間
- 適合無向圖

### 圖形遍歷

**深度優先搜尋 (Depth-First Search, DFS)**

**特性**
- 使用堆疊（或遞迴）實現
- 盡可能深入分支

**應用**
- 尋找連通分量
- 拓撲排序
- 檢測環路

**重要概念**
- **關節點 (Articulation Points)**：移除後圖變不連通的頂點
- **深度優先編號 (DFS Number)**：DFS 首次訪問的序號
- **回邊 (Back Edge)**：連接到祖先的邊
- **前向邊 (Forward Edge)**：連接到後代的邊
- **交叉邊 (Cross Edge)**：連接無祖先-後代關係的邊
- **樹邊 (Tree Edge)**：DFS 樹中的邊
- **Low 值**：通過子樹和回邊能到達的最小 DFS 編號

**廣度優先搜尋 (Breadth-First Search, BFS)**

**特性**
- 使用佇列實現
- 層層擴展搜尋

**應用**
- 最短路徑（無權重圖）
- 最小生成樹

### 最小生成樹 (Minimum Spanning Tree)

**定義**
- 連接所有頂點的最小權重樹
- 包含 n-1 條邊（n 為頂點數）

**Prim 演算法**

**步驟**
1. 從任意頂點開始
2. 每次選擇連接樹和未訪問頂點的最小權重邊
3. 重複直到包含所有頂點

**時間複雜度**：O(V²) 或 O(E log V)

**Kruskal 演算法**

**步驟**
1. 將所有邊按權重排序
2. 依序選擇邊，但不能形成環路
3. 使用 Union-Find 資料結構檢測環路

**時間複雜度**：O(E log E)

**Sollin 演算法**

**步驟**
1. 每個連通分量選擇連接其他分量的最小邊
2. 合併連通分量
3. 重複直到只剩一個分量

### 最短路徑

**Floyd-Warshall 演算法**

**概念**
- 求所有頂點對之間的最短路徑
- 使用動態規劃思想
- 通過每個頂點作為中繼點更新最短路徑

**時間複雜度**：O(V³)
**空間複雜度**：O(V²)

**核心思想**
```
for k in range(V):
    for i in range(V):
        for j in range(V):
            dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
```

### 遞移封閉性 (Transitive Closure)

**定義**
- 決定任意兩頂點間是否存在路徑
- 路徑長度 > 0 時設為 1，否則為 0

**反射遞移封閉性 (Reflexive Transitive Closure)**
- 同遞移封閉性，但對角線元素設為 1

### 拓撲排序 (Topological Sort)

**定義**
- 對有向無環圖 (DAG) 的頂點進行線性排序
- 若存在邊 u → v，則 u 在 v 之前

**演算法**
1. 找出入度為 0 的頂點
2. 輸出該頂點並移除相關邊
3. 重複步驟 1-2 直到所有頂點都被處理

**應用**
- 課程安排
- 編譯依賴關係
- 任務調度

**AOV 網路表示**
- 開頭節點：存放該頂點的入度
- 後續節點：存放相鄰頂點

---

## 排序演算法
[⬆️ 回到目錄](#目錄)

### 簡單排序演算法

**氣泡排序 (Bubble Sort)**

**演算法概念**
- 重複比較相鄰元素，較大者往後移
- 每次遍歷確定一個最大值的位置

**時間複雜度**
- **最佳情況**：O(n)（已排序）
- **最壞情況**：O(n²)
- **平均情況**：O(n²)

**程式碼**
```java
for (int i = 0; i < arr.length - 1; i++) {
    for (int j = 0; j < arr.length - 1 - i; j++) {
        if (arr[j] > arr[j + 1]) {
            swap(arr, j, j + 1);
        }
    }
}
```

**選擇排序 (Selection Sort)**

**演算法概念**
- 每次從未排序部分選出最小值
- 放到已排序部分的末尾

**時間複雜度**
- **所有情況**：O(n²)
- 比較次數固定：n(n-1)/2

**程式碼**
```java
for (int i = 0; i < arr.length - 1; i++) {
    int minIndex = i;
    for (int j = i + 1; j < arr.length; j++) {
        if (arr[j] < arr[minIndex]) {
            minIndex = j;
        }
    }
    if (minIndex != i) {
        swap(arr, i, minIndex);
    }
}
```

**插入排序 (Insertion Sort)**

**演算法概念**
- 將陣列分為已排序和未排序兩部分
- 每次取未排序的元素插入到已排序的正確位置

**時間複雜度**
- **最佳情況**：O(n)（已排序）
- **最壞情況**：O(n²)（反向排序）
- **平均情況**：O(n²)

**程式碼**
```java
for (int i = 1; i < arr.length; i++) {
    int key = arr[i];
    int j = i - 1;
    while (j >= 0 && arr[j] > key) {
        arr[j + 1] = arr[j];
        j--;
    }
    arr[j + 1] = key;
}
```

### 進階排序演算法

**快速排序 (Quick Sort)**

**演算法概念**
- 選擇樞軸 (pivot)
- 將陣列分為小於樞軸和大於樞軸兩部分
- 遞迴排序兩部分

**時間複雜度**
- **最佳情況**：O(n log n)（平衡分割）
- **最壞情況**：O(n²)（最大或最小元素為樞軸）
- **平均情況**：O(n log n)

**程式碼**
```java
public static int partition(int[] arr, int left, int right) {
    int pivot = arr[left];
    while (left < right) {
        while (arr[right] >= pivot && left < right) {
            right--;
        }
        arr[left] = arr[right];
        while (arr[left] <= pivot && left < right) {
            left++;
        }
        arr[right] = arr[left];
    }
    arr[left] = pivot;
    return left;
}
```

**合併排序 (Merge Sort)**

**演算法概念**
- 採用分治法 (Divide and Conquer)
- 將陣列遞迴分割為兩半
- 合併已排序的子陣列

**特性**
- **穩定排序**：相等元素的相對位置不變
- **時間複雜度**：所有情況都是 O(n log n)
- **空間複雜度**：O(n)

**優點**
- 時間複雜度穩定
- 適合大數據排序
- 可以外部排序

**堆積排序 (Heap Sort)**

**演算法概念**
1. 建立最大堆積
2. 將堆積頂端（最大值）與最後元素交換
3. 重新調整堆積
4. 重複步驟 2-3

**特性**
- **時間複雜度**：O(n log n)
- **空間複雜度**：O(1)
- **不穩定排序**

**基數排序 (Radix Sort)**

**演算法概念**
- 非比較型排序
- 按照數字的每一位進行排序
- 從最低位到最高位（或相反）

**時間複雜度**：O(d × (n + k))
- d：數字位數
- n：元素個數
- k：每位可能的值數量

**特性**
- **穩定排序**
- **空間複雜度**：O(n + k)
- 適用於整數或固定長度字串

### 排序演算法比較

| 排序演算法 | 最佳時間 | 平均時間 | 最壞時間 | 空間複雜度 | 穩定性 |
|-----------|----------|----------|----------|------------|---------|
| 氣泡排序 | O(n) | O(n²) | O(n²) | O(1) | 穩定 |
| 選擇排序 | O(n²) | O(n²) | O(n²) | O(1) | 不穩定 |
| 插入排序 | O(n) | O(n²) | O(n²) | O(1) | 穩定 |
| 快速排序 | O(n log n) | O(n log n) | O(n²) | O(log n) | 不穩定 |
| 合併排序 | O(n log n) | O(n log n) | O(n log n) | O(n) | 穩定 |
| 堆積排序 | O(n log n) | O(n log n) | O(n log n) | O(1) | 不穩定 |
| 基數排序 | O(d(n+k)) | O(d(n+k)) | O(d(n+k)) | O(n+k) | 穩定 |

---

## 雜湊表
[⬆️ 回到目錄](#目錄)

### 基本概念

**重要名詞**

**桶 (Bucket)**
- 記憶空間分割成 b 個桶
- 每個桶可存放多筆資料

**槽 (Slot)**
- 每個桶包含 s 個槽
- 每個槽存放一筆記錄

**識別字密度 (Identifier Density)**
- 公式：n / T
- n：實際使用的識別字個數
- T：可能的識別字總數

**負載因子 (Load Factor)**
- 公式：α = n / (s × b)
- 值越大，碰撞機率越高

**碰撞 (Collision)**
- 兩個不同的鍵值對應到同一個桶

**溢位 (Overflow)**
- 鍵值對應的桶已滿

### 雜湊函數

**理想特性**
- **均勻雜湊函數 (Uniform Hashing)**：每個鍵值等機率對應到任一桶
- **完美雜湊 (Perfect Hashing)**：保證不會發生碰撞

**常見雜湊函數**

**除法 (Division Method)**
```
h(k) = k mod m
```
- m 通常選擇質數
- 簡單易實現
- 要避免 m 為 2 的冪次

**平方取中法 (Mid-Square Method)**
1. 將鍵值平方
2. 取平方結果的中間幾位作為雜湊值
3. 例如：8125² = 66015625，取中間三位 156

**摺疊法 (Folding Method)**

**移位摺疊 (Shift Folding)**
- 將鍵值分段後直接相加
- 例如：41|55|28|09|67 → 41+55+28+09+67

**邊界摺疊 (Boundary Folding)**
- 相鄰部分交替反轉再相加
- 例如：41|55|28|09|67 → 41+55+82+90+67

**位數分析法 (Digit Analysis)**
1. 分析鍵值中各位數字的分布
2. 選擇分布最均勻的位數
3. 組合成雜湊值

### 處理碰撞的方法

**開放定址法 (Open Addressing)**

**線性探測 (Linear Probing)**
- 發生碰撞時，依序檢查下一個位置
- 公式：h(k, i) = (h(k) + i) mod m
- **缺點**：容易產生群聚現象 (clustering)

**二次探測 (Quadratic Probing)**
- 使用二次函數探測
- 公式：h(k, i) = (h(k) ± i²) mod m
- 減少群聚問題

**雙重雜湊 (Double Hashing)**
- 使用第二個雜湊函數決定探測步長
- 公式：h(k, i) = (h₁(k) + i × h₂(k)) mod m

**鏈接法 (Chaining)**
- 每個桶維護一個鏈接串列
- 碰撞的元素加入對應桶的串列
- **優點**：簡單、不會滿
- **缺點**：需要額外指標空間

### 雜湊表效能分析

**負載因子與效能關係**
- α < 0.5：效能良好
- α ≈ 0.75：平衡點
- α > 0.9：效能明顯下降

**平均搜尋時間**
- **成功搜尋**：約 1 + α/2
- **失敗搜尋**：約 1 + α

**動態調整**
- 當負載因子過高時，進行重新雜湊 (rehashing)
- 建立更大的雜湊表並重新插入所有元素

---

## 複雜度分析
[⬆️ 回到目錄](#目錄)

### 時間複雜度

**常見複雜度排序**（由快到慢）
1. **O(1)**：常數時間
2. **O(log n)**：對數時間
3. **O(n)**：線性時間
4. **O(n log n)**：線性對數時間
5. **O(n²)**：平方時間
6. **O(n³)**：立方時間
7. **O(2ⁿ)**：指數時間
8. **O(n!)**：階乘時間

**分析技巧**
- **最佳情況 (Best Case)**：輸入最理想的情況
- **最壞情況 (Worst Case)**：輸入最不利的情況
- **平均情況 (Average Case)**：所有可能輸入的平均表現

### 空間複雜度

**考慮因素**
- 輸入空間：存放輸入資料
- 輔助空間：演算法執行時的額外空間
- 輸出空間：存放輸出結果

**常見空間複雜度**
- **O(1)**：就地演算法
- **O(log n)**：遞迴深度
- **O(n)**：線性額外空間
- **O(n²)**：二維陣列

### 資料結構操作複雜度總結

| 資料結構 | 存取 | 搜尋 | 插入 | 刪除 | 空間 |
|----------|------|------|------|------|------|
| 陣列 | O(1) | O(n) | O(n) | O(n) | O(n) |
| 動態陣列 | O(1) | O(n) | O(1)* | O(n) | O(n) |
| 鏈接串列 | O(n) | O(n) | O(1) | O(1) | O(n) |
| 堆疊 | O(n) | O(n) | O(1) | O(1) | O(n) |
| 佇列 | O(n) | O(n) | O(1) | O(1) | O(n) |
| 二元搜尋樹 | O(log n) | O(log n) | O(log n) | O(log n) | O(n) |
| AVL 樹 | O(log n) | O(log n) | O(log n) | O(log n) | O(n) |
| 紅黑樹 | O(log n) | O(log n) | O(log n) | O(log n) | O(n) |
| 雜湊表 | - | O(1)* | O(1)* | O(1)* | O(n) |

*註：平均情況，最壞情況可能較差

### 選擇合適的資料結構

**考慮因素**
1. **操作頻率**：哪些操作最常用？
2. **資料大小**：預期處理多少資料？
3. **記憶體限制**：空間使用是否重要？
4. **實時需求**：是否需要保證最壞情況效能？

**應用場景建議**

**需要快速隨機存取**
- 使用陣列或動態陣列

**頻繁插入刪除**
- 使用鏈接串列或平衡樹

**需要排序資料**
- 使用二元搜尋樹或堆積

**需要快速查找**
- 使用雜湊表或平衡樹

**需要範圍查詢**
- 使用 B 樹或跳躍表

**處理圖形問題**
- 鄰接矩陣（稠密圖）或鄰接串列（稀疏圖）

### 計算複雜度理論

#### P, NP, NP-Complete, NP-Hard 問題簡單理解

**用生活例子理解**

想像你是一個拼圖愛好者：

**P 類問題 = 容易解決的拼圖**
- **定義**：你可以在合理時間內完成的拼圖
- **特點**：有明確的方法，步驟清楚
- **例子**：
  - 50 片的兒童拼圖
  - 找最短路徑（用 GPS 導航）
  - 排序一堆數字

**NP 類問題 = 難解但易驗證的拼圖**
- **定義**：解決很困難，但如果有人給你答案，你能快速檢查對錯
- **關鍵**：「檢查答案」比「找答案」容易很多
- **例子**：
  - 1000 片拼圖：很難拼完，但看到完成品能馬上知道對錯
  - 數獨：填完很困難，但檢查答案只需幾分鐘

**NP-Complete 問題 = 最難的那一類**
- **定義**：NP 問題中最困難的，其他 NP 問題都可以轉換成它
- **重要性**：如果能快速解決任何一個 NP-Complete 問題，就能快速解決所有 NP 問題
- **現實**：目前沒有人找到快速解法

**NP-Hard 問題 = 至少和 NP-Complete 一樣難**
- **定義**：比 NP-Complete 更難或一樣難
- **特點**：甚至連檢查答案都可能很困難

#### 具體問題舉例

**旅行推銷員問題 (TSP) - NP-Complete**

**問題描述**
小明是推銷員，要拜訪 10 個城市，每個城市去一次，最後回到起點。
怎樣安排路線，總距離最短？

**為什麼是 NP-Complete？**
- **解決困難**：10 個城市有 3,628,800 種路線！需要檢查每一種
- **驗證容易**：給你一條路線，用計算機加一下距離就知道總長度
- **實際例子**：
  ```
  城市：台北 → 台中 → 高雄 → 台南 → 台北
  距離：100 + 150 + 50 + 200 = 500 公里
  ```

**背包問題 - NP-Complete**

**問題描述**
你有一個背包，容量 10 公斤。有以下物品：
- 筆電：3 公斤，價值 1000 元
- 相機：2 公斤，價值 800 元
- 書籍：4 公斤，價值 400 元
- 衣服：3 公斤，價值 300 元

怎樣裝最有價值？

**為什麼是 NP-Complete？**
- **解決困難**：要試所有組合 (2^n 種可能)
- **驗證容易**：
  ```
  選擇：筆電 + 相機 + 衣服
  重量：3 + 2 + 3 = 8 公斤 ≤ 10 公斤 ✓
  價值：1000 + 800 + 300 = 2100 元
  ```

**圖著色問題 - NP-Complete**

**問題描述**
你要給地圖上的國家塗顏色，相鄰國家不能同色。
最少需要幾種顏色？

**具體例子**
```
     A
   /   \
  B --- C
   \   /
     D
```
- A-B-C-D 四個區域
- A 和 B 相鄰，A 和 C 相鄰...
- 最少需要 3 種顏色

**為什麼是 NP-Complete？**
- **解決困難**：要試所有塗色方案
- **驗證容易**：檢查相鄰區域是否同色

#### 實際處理策略

**面對 NP-Complete 問題時的做法**

**1. 近似演算法 - 找"夠好"的答案**

TSP 的貪心法：
```
1. 從起點開始
2. 每次選擇最近的未訪問城市
3. 直到所有城市都訪問過
```
- **優點**：快速得到答案
- **缺點**：不是最佳解，但通常差不多

**2. 啟發式演算法 - 聰明的猜測**

模擬退火法：
```
1. 隨機產生一個解
2. 隨機修改一點點
3. 如果變好就接受，變差也有機會接受
4. 重複很多次
```

**3. 分支定界法 - 聰明的暴力法**

```
1. 列出所有可能解
2. 估算每個解的下限
3. 如果下限已經比目前最佳解差，就不用算了
4. 只計算有希望的解
```

**4. 動態規劃 - 記住算過的結果**

```
1. 把大問題分解成小問題
2. 先解決小問題
3. 用小問題的答案組合成大問題的答案
4. 避免重複計算
```

#### P vs NP 問題的實際意義

**如果 P = NP（找到快速解法）**
- 所有 NP 問題都能快速解決
- 密碼學會被破解（RSA 加密等）
- 人工智慧會有重大突破
- 很多「困難」問題變得簡單

**如果 P ≠ NP（目前大家的想法）**
- 有些問題天生就是困難的
- 需要用近似演算法處理
- 密碼學保持安全
- 計算有其極限

**簡單判斷方法**
- **能快速解決** → P 問題
- **難解決，但給答案能快速檢查** → 可能是 NP-Complete
- **連檢查答案都很困難** → 可能是 NP-Hard

---